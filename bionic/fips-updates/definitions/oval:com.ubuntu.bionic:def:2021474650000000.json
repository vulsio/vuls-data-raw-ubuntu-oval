{
	"class": "vulnerability",
	"id": "oval:com.ubuntu.bionic:def:2021474650000000",
	"version": "1",
	"metadata": {
		"title": "CVE-2021-47465 on Ubuntu 18.04 FIPS Compliant (bionic) - medium",
		"description": "In the Linux kernel, the following vulnerability has been resolved: KVM:PPC: Book3S HV: Fix stack handling in idle_kvm_start_guest() In commit10d91611f426 (\"powerpc/64s: Reimplement book3s idle code in C\")kvm_start_guest() became idle_kvm_start_guest(). The old code allocated astack frame on the emergency stack, but didn't use the frame to storeanything, and also didn't store anything in its caller's frame.idle_kvm_start_guest() on the other hand is written more like a normal Cfunction, it creates a frame on entry, and also stores CR/LR into itscallers frame (per the ABI). The problem is that there is no caller frameon the emergency stack. The emergency stack for a given CPU is allocatedwith: paca_ptrs[i]->emergency_sp = alloc_stack(limit, i) + THREAD_SIZE; Soemergency_sp actually points to the first address above the emergency stackallocation for a given CPU, we must not store above it without firstdecrementing it to create a frame. This is different to the regular kernelstack, paca->kstack, which is initialised to point at an initial frame thatis ready to use. idle_kvm_start_guest() stores the backchain, CR and LR allof which write outside the allocation for the emergency stack. It thencreates a stack frame and saves the non-volatile registers. Unfortunatelythe frame it creates is not large enough to fit the non-volatiles, and sothe saving of the non-volatile registers also writes outside the emergencystack allocation. The end result is that we corrupt whatever is at 0-24bytes, and 112-248 bytes above the emergency stack allocation. In practicethis has gone unnoticed because the memory immediately above the emergencystack happens to be used for other stack allocations, either another CPUsmc_emergency_sp or an IRQ stack. See the order of calls toirqstack_early_init() and emergency_stack_init(). The low addresses ofanother stack are the top of that stack, and so are only used if that stackis under extreme pressue, which essentially never happens in practice - andif it did there's a high likelyhood we'd crash due to that stackoverflowing. Still, we shouldn't be corrupting someone else's stack, and itis purely luck that we aren't corrupting something else. To fix it we saveCR/LR into the caller's frame using the existing r1 on entry, we thencreate a SWITCH_FRAME_SIZE frame (which has space for pt_regs) on theemergency stack with the backchain pointing to the existing stack, and thenfinally we switch to the new frame on the emergency stack.",
		"affected": {
			"family": "unix",
			"platform": "Ubuntu 18.04 FIPS Compliant"
		},
		"reference": {
			"source": "CVE",
			"ref_id": "CVE-2021-47465",
			"ref_url": "https://www.cve.org/CVERecord?id=CVE-2021-47465"
		},
		"advisory": {
			"severity": "Medium",
			"rights": "Copyright (C) 2024 Canonical Ltd.",
			"public_date": "2024-05-22 07:15:00 UTC",
			"cve": {
				"text": "CVE-2021-47465",
				"href": "https://ubuntu.com/security/CVE-2021-47465",
				"public": "20240522"
			}
		}
	},
	"notes": {},
	"criteria": {
		"criterias": [
			{
				"operator": "OR",
				"criterions": [
					{
						"test_ref": "oval:com.ubuntu.bionic:tst:201585530000010",
						"comment": "linux-fips package in fips-updates/bionic is affected and may need fixing."
					},
					{
						"test_ref": "oval:com.ubuntu.bionic:tst:201245420000320",
						"comment": "linux-aws-fips package in fips-updates/bionic is affected and may need fixing."
					},
					{
						"test_ref": "oval:com.ubuntu.bionic:tst:201245420000330",
						"comment": "linux-azure-fips package in fips-updates/bionic is affected and may need fixing."
					},
					{
						"test_ref": "oval:com.ubuntu.bionic:tst:201245420000340",
						"comment": "linux-gcp-fips package in fips-updates/bionic is affected and may need fixing."
					}
				]
			}
		]
	}
}
