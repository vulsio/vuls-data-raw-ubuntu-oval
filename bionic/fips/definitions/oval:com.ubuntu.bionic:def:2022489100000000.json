{
	"class": "vulnerability",
	"id": "oval:com.ubuntu.bionic:def:2022489100000000",
	"version": "1",
	"metadata": {
		"title": "CVE-2022-48910 on Ubuntu 18.04 FIPS Certified (bionic) - medium",
		"description": "In the Linux kernel, the following vulnerability has been resolved:net: ipv6: ensure we call ipv6_mc_down() at most onceThere are two reasons for addrconf_notify() to be called with NETDEV_DOWN:either the network device is actually going down, or IPv6 was disabledon the interface.If either of them stays down while the other is toggled, we repeatedlycall the code for NETDEV_DOWN, including ipv6_mc_down(), while nevercalling the corresponding ipv6_mc_up() in between. This will cause anew entry in idev->mc_tomb to be allocated for each multicast groupthe interface is subscribed to, which in turn leaks one struct ifmcaddr6per nontrivial multicast group the interface is subscribed to.The following reproducer will leak at least $n objects:ip addr add ff2e::4242/32 dev eth0 autojoinsysctl -w net.ipv6.conf.eth0.disable_ipv6=1for i in $(seq 1 $n); do\tip link set up eth0; ip link set down eth0doneJoining groups with IPV6_ADD_MEMBERSHIP (unprivileged) or setting thesysctl net.ipv6.conf.eth0.forwarding to 1 (=> subscribing to ff02::2)can also be used to create a nontrivial idev->mc_list, which will theleak objects with the right up-down-sequence.Based on both sources for NETDEV_DOWN events the interface IPv6 stateshould be considered: - not ready if the network interface is not ready OR IPv6 is disabled   for it - ready if the network interface is ready AND IPv6 is enabled for itThe functions ipv6_mc_up() and ipv6_down() should only be run when thisstate changes.Implement this by remembering when the IPv6 state is ready, and onlyrun ipv6_mc_down() if it actually changed from ready to not ready.The other direction (not ready -> ready) already works correctly, as: - the interface notification triggered codepath for NETDEV_UP /   NETDEV_CHANGE returns early if ipv6 is disabled, and - the disable_ipv6=0 triggered codepath skips fully initializing the   interface as long as addrconf_link_ready(dev) returns false - calling ipv6_mc_up() repeatedly does not leak anything",
		"affected": {
			"family": "unix",
			"platform": "Ubuntu 18.04 FIPS Certified"
		},
		"reference": {
			"source": "CVE",
			"ref_id": "CVE-2022-48910",
			"ref_url": "https://www.cve.org/CVERecord?id=CVE-2022-48910"
		},
		"advisory": {
			"severity": "Medium",
			"rights": "Copyright (C) 2024 Canonical Ltd.",
			"public_date": "2024-08-22 02:15:00 UTC",
			"cve": {
				"text": "CVE-2022-48910",
				"href": "https://ubuntu.com/security/CVE-2022-48910",
				"public": "20240822"
			}
		}
	},
	"notes": {},
	"criteria": {
		"criterias": [
			{
				"operator": "OR",
				"criterions": [
					{
						"test_ref": "oval:com.ubuntu.bionic:tst:201245420000350",
						"comment": "linux-fips package in fips/bionic is affected. An update containing the fix has been completed and is pending publication."
					},
					{
						"test_ref": "oval:com.ubuntu.bionic:tst:201245420000320",
						"comment": "linux-aws-fips package in fips/bionic is affected. An update containing the fix has been completed and is pending publication."
					},
					{
						"test_ref": "oval:com.ubuntu.bionic:tst:201245420000330",
						"comment": "linux-azure-fips package in fips/bionic is affected. An update containing the fix has been completed and is pending publication."
					},
					{
						"test_ref": "oval:com.ubuntu.bionic:tst:201245420000340",
						"comment": "linux-gcp-fips package in fips/bionic is affected. An update containing the fix has been completed and is pending publication."
					}
				]
			}
		]
	}
}
