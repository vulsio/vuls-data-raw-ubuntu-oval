{
	"class": "vulnerability",
	"id": "oval:com.ubuntu.bionic:def:2022487210000000",
	"version": "1",
	"metadata": {
		"title": "CVE-2022-48721 on Ubuntu 18.04 FIPS Certified (bionic) - medium",
		"description": "In the Linux kernel, the following vulnerability has been resolved:net/smc: Forward wakeup to smc socket waitqueue after fallbackWhen we replace TCP with SMC and a fallback occurs, there may besome socket waitqueue entries remaining in smc socket->wq, suchas eppoll_entries inserted by userspace applications.After the fallback, data flows over TCP/IP and only clcsocket->wqwill be woken up. Applications can't be notified by the entrieswhich were inserted in smc socket->wq before fallback. So we needa mechanism to wake up smc socket->wq at the same time if someentries remaining in it.The current workaround is to transfer the entries from smc socket->wqto clcsock->wq during the fallback. But this may cause a crashlike this: general protection fault, probably for non-canonical address0xdead000000000100: 0000 [#1] PREEMPT SMP PTI CPU: 3 PID: 0 Comm: swapper/3 Kdump: loaded Tainted: G E     5.16.0+ #107 RIP: 0010:__wake_up_common+0x65/0x170 Call Trace:  <IRQ>  __wake_up_common_lock+0x7a/0xc0  sock_def_readable+0x3c/0x70  tcp_data_queue+0x4a7/0xc40  tcp_rcv_established+0x32f/0x660  ? sk_filter_trim_cap+0xcb/0x2e0  tcp_v4_do_rcv+0x10b/0x260  tcp_v4_rcv+0xd2a/0xde0  ip_protocol_deliver_rcu+0x3b/0x1d0  ip_local_deliver_finish+0x54/0x60  ip_local_deliver+0x6a/0x110  ? tcp_v4_early_demux+0xa2/0x140  ? tcp_v4_early_demux+0x10d/0x140  ip_sublist_rcv_finish+0x49/0x60  ip_sublist_rcv+0x19d/0x230  ip_list_rcv+0x13e/0x170  __netif_receive_skb_list_core+0x1c2/0x240  netif_receive_skb_list_internal+0x1e6/0x320  napi_complete_done+0x11d/0x190  mlx5e_napi_poll+0x163/0x6b0 [mlx5_core]  __napi_poll+0x3c/0x1b0  net_rx_action+0x27c/0x300  __do_softirq+0x114/0x2d2  irq_exit_rcu+0xb4/0xe0  common_interrupt+0xba/0xe0  </IRQ>  <TASK>The crash is caused by privately transferring waitqueue entries fromsmc socket->wq to clcsock->wq. The owners of these entries, such asepoll, have no idea that the entries have been transferred to adifferent socket wait queue and still use original waitqueue spinlock(smc socket->wq.wait.lock) to make the entries operation exclusive,but it doesn't work. The operations to the entries, such as removingfrom the waitqueue (now is clcsock->wq after fallback), may cause acrash when clcsock waitqueue is being iterated over at the moment.This patch tries to fix this by no longer transferring wait queueentries privately, but introducing own implementations of clcsock'scallback functions in fallback situation. The callback functions willforward the wakeup to smc socket->wq if clcsock->wq is actually wokenup and smc socket->wq has remaining entries.",
		"affected": {
			"family": "unix",
			"platform": "Ubuntu 18.04 FIPS Certified"
		},
		"reference": {
			"source": "CVE",
			"ref_id": "CVE-2022-48721",
			"ref_url": "https://www.cve.org/CVERecord?id=CVE-2022-48721"
		},
		"advisory": {
			"severity": "Medium",
			"rights": "Copyright (C) 2024 Canonical Ltd.",
			"public_date": "2024-06-20",
			"cve": {
				"text": "CVE-2022-48721",
				"href": "https://ubuntu.com/security/CVE-2022-48721",
				"public": "20240620"
			}
		}
	},
	"notes": {},
	"criteria": {
		"criterias": [
			{
				"operator": "OR",
				"criterions": [
					{
						"test_ref": "oval:com.ubuntu.bionic:tst:201585530000010",
						"comment": "linux-fips package in fips/bionic is affected and may need fixing."
					},
					{
						"test_ref": "oval:com.ubuntu.bionic:tst:201245420000320",
						"comment": "linux-aws-fips package in fips/bionic is affected and may need fixing."
					},
					{
						"test_ref": "oval:com.ubuntu.bionic:tst:201245420000330",
						"comment": "linux-azure-fips package in fips/bionic is affected and may need fixing."
					},
					{
						"test_ref": "oval:com.ubuntu.bionic:tst:201245420000340",
						"comment": "linux-gcp-fips package in fips/bionic is affected and may need fixing."
					}
				]
			}
		]
	}
}
